<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gemini Live Text Chat</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
      }
      .container {
        max-width: 600px;
        margin: 0 auto;
        background: white;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        overflow: hidden;
        height: 80vh;
        display: flex;
        flex-direction: column;
      }
      .header {
        background: linear-gradient(135deg, #4285f4 0%, #34a853 100%);
        color: white;
        padding: 20px;
        text-align: center;
      }
      .header h1 {
        font-size: 1.8em;
        margin-bottom: 5px;
      }
      .status {
        background: #f8f9fa;
        padding: 10px 20px;
        border-bottom: 1px solid #ddd;
        font-size: 0.9em;
      }
      .status-connected {
        color: #28a745;
      }
      .status-disconnected {
        color: #dc3545;
      }
      .chat-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }
      .messages {
        flex: 1;
        padding: 20px;
        overflow-y: auto;
        background: #f8f9fa;
      }
      .message {
        margin-bottom: 15px;
        padding: 12px 16px;
        border-radius: 12px;
        max-width: 80%;
        word-wrap: break-word;
      }
      .message-user {
        background: #007bff;
        color: white;
        margin-left: auto;
        border-bottom-right-radius: 4px;
      }
      .message-ai {
        background: white;
        border: 1px solid #ddd;
        margin-right: auto;
        border-bottom-left-radius: 4px;
      }
      .message-error {
        background: #f8d7da;
        color: #721c24;
        border: 1px solid #f5c6cb;
        margin: 0 auto;
        text-align: center;
      }
      .message-time {
        font-size: 0.75em;
        opacity: 0.7;
        margin-bottom: 4px;
      }
      .input-container {
        padding: 20px;
        background: white;
        border-top: 1px solid #ddd;
      }
      .input-group {
        display: flex;
        gap: 10px;
      }
      .text-input {
        flex: 1;
        padding: 12px 16px;
        border: 2px solid #ddd;
        border-radius: 25px;
        font-size: 1em;
        outline: none;
        transition: border-color 0.3s;
      }
      .text-input:focus {
        border-color: #007bff;
      }
      .send-btn {
        background: #007bff;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 25px;
        cursor: pointer;
        font-size: 1em;
        transition: background-color 0.3s;
      }
      .send-btn:hover:not(:disabled) {
        background: #0056b3;
      }
      .send-btn:disabled {
        background: #ccc;
        cursor: not-allowed;
      }
      .connect-btn {
        background: #28a745;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 20px;
        cursor: pointer;
        font-size: 0.9em;
        margin-left: 10px;
      }
      .connect-btn:hover:not(:disabled) {
        background: #218838;
      }
      .connect-btn:disabled {
        background: #ccc;
        cursor: not-allowed;
      }
      .media-controls {
        display: flex;
        gap: 10px;
        margin-bottom: 10px;
        flex-wrap: wrap;
      }
      .media-btn {
        background: #6c757d;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 20px;
        cursor: pointer;
        font-size: 0.9em;
        transition: background-color 0.3s;
      }
      .media-btn:hover:not(:disabled) {
        background: #5a6268;
      }
      .media-btn:disabled {
        background: #ccc;
        cursor: not-allowed;
      }
      .media-btn.active {
        background: #dc3545;
      }
      .media-btn.active:hover {
        background: #c82333;
      }
      .media-status {
        font-size: 0.8em;
        color: #666;
        margin-top: 5px;
      }
      .typing-indicator {
        display: none;
        padding: 12px 16px;
        background: #e9ecef;
        border-radius: 12px;
        margin-bottom: 15px;
        max-width: 80%;
        margin-right: auto;
      }
      .typing-indicator.show {
        display: block;
      }
      .typing-dots::after {
        content: "...";
        animation: typing 1.5s infinite;
      }
      @keyframes typing {
        0%,
        60% {
          content: "...";
        }
        20% {
          content: ".";
        }
        40% {
          content: "..";
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>üí¨ Gemini Live Text Chat</h1>
        <p>Tr√≤ chuy·ªán vƒÉn b·∫£n v·ªõi Gemini AI</p>
      </div>
      <div class="status">
        <span id="status">üî¥ Ch∆∞a k·∫øt n·ªëi</span>
        <button id="connectBtn" class="connect-btn">K·∫øt n·ªëi</button>
      </div>
      <div class="chat-container">
        <div class="messages" id="messages">
          <div class="message message-ai">
            <div class="message-time">H·ªá th·ªëng</div>
            <div>
              Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi Gemini Live Text Chat! Nh·∫•n "K·∫øt n·ªëi" ƒë·ªÉ b·∫Øt
              ƒë·∫ßu tr√≤ chuy·ªán.
            </div>
          </div>
        </div>
        <div class="typing-indicator" id="typingIndicator">
          <div class="message-time">Gemini</div>
          <div>ƒêang tr·∫£ l·ªùi<span class="typing-dots"></span></div>
        </div>
      </div>
      <div class="input-container">
        <div class="media-controls">
          <button id="screenBtn" class="media-btn" disabled>
            üìπ Chia s·∫ª m√†n h√¨nh
          </button>

          <button id="stopBtn" class="media-btn" disabled style="display: none">
            ‚èπÔ∏è D·ª´ng
          </button>
        </div>
        <div class="media-status" id="mediaStatus"></div>
        <div class="input-group">
          <input
            type="text"
            id="textInput"
            class="text-input"
            placeholder="H·ªèi v·ªÅ video ƒëang chia s·∫ª..."
            disabled
          />
          <button id="sendBtn" class="send-btn" disabled>G·ª≠i</button>
        </div>
      </div>
    </div>

    <script>
      class TextChatClient {
        constructor() {
          this.ws = null;
          this.isConnected = false;
          this.isWaitingResponse = false;
          this.currentAiMessage = null;
          this.currentAiContent = "";
          this.mediaStream = null;
          this.mediaRecorder = null;
          this.isRecording = false;
          this.videoChunks = [];
          this.audioChunks = [];
          this.frameSequence = []; // Array ƒë·ªÉ l∆∞u t·∫•t c·∫£ frames
          this.maxFrames = 30; // T·ªëi ƒëa 30 frames (30 gi√¢y)
          this.initializeElements();
          this.setupEventListeners();
        }

        initializeElements() {
          this.statusEl = document.getElementById("status");
          this.connectBtn = document.getElementById("connectBtn");
          this.textInput = document.getElementById("textInput");
          this.sendBtn = document.getElementById("sendBtn");
          this.messagesEl = document.getElementById("messages");
          this.typingIndicator = document.getElementById("typingIndicator");
          this.screenBtn = document.getElementById("screenBtn");
          this.stopBtn = document.getElementById("stopBtn");
          this.mediaStatus = document.getElementById("mediaStatus");
        }

        setupEventListeners() {
          this.connectBtn.addEventListener("click", () =>
            this.toggleConnection()
          );
          this.sendBtn.addEventListener("click", () => this.sendMessage());
          this.screenBtn.addEventListener("click", () =>
            this.startScreenShare()
          );

          this.stopBtn.addEventListener("click", () => this.stopCapture());
          this.textInput.addEventListener("keypress", (e) => {
            if (e.key === "Enter" && !e.shiftKey) {
              e.preventDefault();
              this.sendMessage();
            }
          });
        }

        async toggleConnection() {
          if (this.isConnected) {
            this.disconnect();
          } else {
            await this.connect();
          }
        }

        async connect() {
          try {
            this.updateStatus("üü° ƒêang k·∫øt n·ªëi...", false);
            this.connectBtn.disabled = true;

            const protocol =
              window.location.protocol === "https:" ? "wss:" : "ws:";
            const wsUrl = `${protocol}//${window.location.host}`;

            this.ws = new WebSocket(wsUrl);

            this.ws.onopen = () => {
              this.ws.send(
                JSON.stringify({
                  type: "connect",
                  systemInstruction:
                    "B·∫°n l√† m·ªôt tr·ª£ l√Ω AI th√¥ng minh. H√£y tr·∫£ l·ªùi ng·∫Øn g·ªçn v√† th√¢n thi·ªán b·∫±ng ti·∫øng Vi·ªát.",
                })
              );
            };

            this.ws.onmessage = (event) => {
              const message = JSON.parse(event.data);
              this.handleWebSocketMessage(message);
            };

            this.ws.onclose = () => {
              this.isConnected = false;
              this.updateStatus("üî¥ M·∫•t k·∫øt n·ªëi", false);
              this.connectBtn.textContent = "K·∫øt n·ªëi";
              this.connectBtn.disabled = false;
              this.textInput.disabled = true;
              this.sendBtn.disabled = true;
              this.hideTypingIndicator();
            };

            this.ws.onerror = () => {
              this.updateStatus("üî¥ L·ªói k·∫øt n·ªëi", false);
              this.connectBtn.disabled = false;
              this.addMessage("error", "L·ªói WebSocket");
            };
          } catch (error) {
            this.updateStatus("üî¥ L·ªói k·∫øt n·ªëi", false);
            this.connectBtn.disabled = false;
            this.addMessage("error", "Kh√¥ng th·ªÉ k·∫øt n·ªëi: " + error.message);
          }
        }

        handleWebSocketMessage(message) {
          switch (message.type) {
            case "connected":
              this.isConnected = true;
              this.updateStatus("üü¢ ƒê√£ k·∫øt n·ªëi", true);
              this.connectBtn.textContent = "Ng·∫Øt k·∫øt n·ªëi";
              this.connectBtn.disabled = false;
              this.textInput.disabled = false;
              this.sendBtn.disabled = false;
              this.screenBtn.disabled = false;
              this.addMessage("ai", message.message);
              break;
            case "textChunk":
              this.hideTypingIndicator();
              this.appendToAiMessage(message.text);
              break;

            case "turnComplete":
              this.finishAiMessage();
              this.isWaitingResponse = false;
              this.sendBtn.disabled = false;
              break;
            case "videoReceived":
              this.addMessage("ai", "‚úÖ " + message.message);
              break;

            case "processing":
              this.showTypingIndicator();
              break;

            case "error":
              this.hideTypingIndicator();
              this.addMessage("error", message.message);
              this.isWaitingResponse = false;
              this.sendBtn.disabled = false;
              break;
          }
        }

        appendToAiMessage(text) {
          if (!this.currentAiMessage) {
            // T·∫°o message m·ªõi cho AI
            this.currentAiMessage = document.createElement("div");
            this.currentAiMessage.className = "message message-ai";

            const timeDiv = document.createElement("div");
            timeDiv.className = "message-time";
            timeDiv.textContent = new Date().toLocaleTimeString();

            const contentDiv = document.createElement("div");
            contentDiv.className = "message-content";

            this.currentAiMessage.appendChild(timeDiv);
            this.currentAiMessage.appendChild(contentDiv);
            this.messagesEl.appendChild(this.currentAiMessage);

            this.currentAiContent = "";
          }

          // Append text v√†o content hi·ªán t·∫°i
          this.currentAiContent += text;
          const contentDiv =
            this.currentAiMessage.querySelector(".message-content");
          contentDiv.textContent = this.currentAiContent;

          this.scrollToBottom();
        }

        finishAiMessage() {
          this.currentAiMessage = null;
          this.currentAiContent = "";
        }

        disconnect() {
          if (this.ws) {
            this.ws.send(JSON.stringify({ type: "disconnect" }));
            this.ws.close();
            this.ws = null;
          }
          this.stopCapture(); // Stop any ongoing media capture
          this.isConnected = false;
          this.updateStatus("üî¥ Ch∆∞a k·∫øt n·ªëi", false);
          this.connectBtn.textContent = "K·∫øt n·ªëi";
          this.textInput.disabled = true;
          this.sendBtn.disabled = true;
          this.screenBtn.disabled = true;
          this.hideTypingIndicator();
        }

        updateStatus(text, connected) {
          this.statusEl.textContent = text;
          this.statusEl.className = connected
            ? "status-connected"
            : "status-disconnected";
        }

        async sendMessage() {
          const text = this.textInput.value.trim();
          if (!text || !this.isConnected || this.isWaitingResponse) return;

          this.addMessage("user", text);

          // Th√¥ng b√°o n·∫øu ƒëang g·ª≠i k√®m video
          if (this.isRecording) {
            this.addMessage(
              "system",
              "üìπ ƒêang g·ª≠i c√¢u h·ªèi k√®m video context ƒë·∫øn Gemini..."
            );
          }

          this.textInput.value = "";
          this.isWaitingResponse = true;
          this.sendBtn.disabled = true;

          if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            // N·∫øu c√≥ frame sequence, g·ª≠i t·∫•t c·∫£ frames
            if (this.frameSequence && this.frameSequence.length > 0) {
              this.sendTextWithFrameSequence(text, this.frameSequence);
              // X√≥a t·∫•t c·∫£ frames c≈© v√† b·∫Øt ƒë·∫ßu sequence m·ªõi
              this.clearFrameSequence();
            } else {
              // Ch·ªâ g·ª≠i text n·∫øu kh√¥ng c√≥ frames
              this.ws.send(
                JSON.stringify({
                  type: "sendText",
                  text: text,
                })
              );
            }
          } else {
            this.addMessage("error", "Kh√¥ng c√≥ k·∫øt n·ªëi WebSocket");
            this.isWaitingResponse = false;
            this.sendBtn.disabled = false;
          }
        }

        showTypingIndicator() {
          this.typingIndicator.classList.add("show");
          this.scrollToBottom();
        }

        hideTypingIndicator() {
          this.typingIndicator.classList.remove("show");
        }

        addMessage(type, content) {
          const messageDiv = document.createElement("div");
          messageDiv.className = `message message-${type}`;

          const timeDiv = document.createElement("div");
          timeDiv.className = "message-time";
          timeDiv.textContent = new Date().toLocaleTimeString();

          const contentDiv = document.createElement("div");
          contentDiv.className = "message-content";
          contentDiv.textContent = content;

          messageDiv.appendChild(timeDiv);
          messageDiv.appendChild(contentDiv);

          this.messagesEl.appendChild(messageDiv);
          this.scrollToBottom();
        }

        scrollToBottom() {
          this.messagesEl.scrollTop = this.messagesEl.scrollHeight;
        }

        async startScreenShare() {
          try {
            this.mediaStatus.textContent =
              "üîÑ ƒêang y√™u c·∫ßu quy·ªÅn chia s·∫ª m√†n h√¨nh...";

            this.mediaStream = await navigator.mediaDevices.getDisplayMedia({
              video: { mediaSource: "screen" },
              audio: true, // Capture system audio
            });

            this.setupVideoFrameCapture();
            this.updateMediaButtons(true);
            this.mediaStatus.textContent =
              "üìπ ƒêang thu video t·ª´ m√†n h√¨nh - H√£y h·ªèi v·ªÅ n·ªôi dung!";
          } catch (error) {
            console.error("Error starting screen share:", error);
            this.mediaStatus.textContent =
              "‚ùå Kh√¥ng th·ªÉ chia s·∫ª m√†n h√¨nh: " + error.message;
          }
        }

        setupVideoFrameCapture() {
          // Thay ƒë·ªïi approach: Capture image frames thay v√¨ video
          console.log("üìπ Setting up image frame capture instead of video");

          // T·∫°o video element ƒë·ªÉ hi·ªÉn th·ªã stream
          this.videoElement = document.createElement("video");
          this.videoElement.srcObject = this.mediaStream;
          this.videoElement.play();

          // T·∫°o canvas ƒë·ªÉ capture frames
          this.canvas = document.createElement("canvas");
          this.ctx = this.canvas.getContext("2d");

          this.videoElement.onloadedmetadata = () => {
            // T·ªëi ∆∞u h√≥a resolution ƒë·ªÉ gi·∫£m k√≠ch th∆∞·ªõc file
            const maxWidth = 1280;
            const maxHeight = 720;

            let { videoWidth, videoHeight } = this.videoElement;

            // Scale down n·∫øu qu√° l·ªõn
            if (videoWidth > maxWidth || videoHeight > maxHeight) {
              const ratio = Math.min(
                maxWidth / videoWidth,
                maxHeight / videoHeight
              );
              videoWidth = Math.floor(videoWidth * ratio);
              videoHeight = Math.floor(videoHeight * ratio);
            }

            this.canvas.width = videoWidth;
            this.canvas.height = videoHeight;

            console.log(
              "üìπ Optimized dimensions:",
              this.canvas.width,
              "x",
              this.canvas.height
            );

            // Capture frame ƒë·∫ßu ti√™n
            this.captureCurrentFrame();

            // Capture frame m·ªói 1 gi√¢y ƒë·ªÉ t·∫°o sequence
            this.frameInterval = setInterval(() => {
              this.captureCurrentFrame();
            }, 1000);

            this.isRecording = true;
            this.mediaStatus.textContent =
              "üìπ ƒêang capture frames - S·∫µn s√†ng cho c√¢u h·ªèi";
          };
        }

        captureCurrentFrame() {
          if (!this.videoElement || !this.canvas || !this.isRecording) return;

          try {
            // Draw current video frame to canvas
            this.ctx.drawImage(
              this.videoElement,
              0,
              0,
              this.canvas.width,
              this.canvas.height
            );

            // Convert to JPEG blob v·ªõi compression t·ªëi ∆∞u
            this.canvas.toBlob(
              (blob) => {
                if (blob) {
                  // Th√™m frame v√†o sequence
                  this.frameSequence.push({
                    blob: blob,
                    timestamp: Date.now(),
                    size: blob.size,
                  });

                  // Gi·ªõi h·∫°n s·ªë frames (FIFO - First In First Out)
                  if (this.frameSequence.length > this.maxFrames) {
                    this.frameSequence.shift(); // X√≥a frame c≈© nh·∫•t
                  }

                  const sizeKB = Math.round(blob.size / 1024);
                  const totalFrames = this.frameSequence.length;
                  console.log(
                    `üì∏ Frame ${totalFrames} captured:`,
                    blob.size,
                    "bytes",
                    `(${sizeKB}KB)`
                  );

                  // C·∫£nh b√°o n·∫øu file qu√° l·ªõn
                  if (sizeKB > 500) {
                    console.warn("‚ö†Ô∏è Frame size l·ªõn:", sizeKB, "KB");
                  }

                  this.mediaStatus.textContent = `üì∏ ${totalFrames} frames s·∫µn s√†ng - H√£y h·ªèi!`;
                } else {
                  console.error("‚ùå Failed to capture frame");
                }
              },
              "image/jpeg",
              0.7 // Gi·∫£m quality ƒë·ªÉ file nh·ªè h∆°n
            );
          } catch (error) {
            console.error("Error capturing frame:", error);
          }
        }

        async sendTextWithFrameSequence(text, frameSequence) {
          if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
            return;
          }

          try {
            console.log(
              `üì§ Sending text with ${frameSequence.length} frames:`,
              text
            );

            // Convert t·∫•t c·∫£ frames th√†nh base64
            const frameDataArray = [];
            let totalSize = 0;

            for (let i = 0; i < frameSequence.length; i++) {
              const frame = frameSequence[i];
              const arrayBuffer = await frame.blob.arrayBuffer();
              const base64Data = btoa(
                String.fromCharCode(...new Uint8Array(arrayBuffer))
              );

              frameDataArray.push({
                data: base64Data,
                mimeType: frame.blob.type,
                timestamp: frame.timestamp,
                size: frame.size,
              });

              totalSize += frame.size;
            }

            console.log(
              `üìä Total frames: ${
                frameSequence.length
              }, Total size: ${Math.round(totalSize / 1024)}KB`
            );

            // G·ª≠i text k√®m t·∫•t c·∫£ frames
            this.ws.send(
              JSON.stringify({
                type: "sendTextWithFrameSequence",
                text: text,
                frames: frameDataArray,
                totalFrames: frameSequence.length,
                totalSize: totalSize,
              })
            );
          } catch (error) {
            console.error("Error sending text with frame sequence:", error);
            // Fallback: ch·ªâ g·ª≠i text
            this.ws.send(
              JSON.stringify({
                type: "sendText",
                text: text,
              })
            );
          }
        }

        clearFrameSequence() {
          console.log(`üóëÔ∏è Clearing ${this.frameSequence.length} old frames`);
          this.frameSequence = [];
          this.mediaStatus.textContent =
            "üì∏ ƒê√£ x√≥a frames c≈© - ƒêang thu th·∫≠p frames m·ªõi...";
        }

        restartVideoRecording() {
          if (!this.mediaStream) return;

          // X√≥a video c≈©
          this.currentVideoBlob = null;

          // T·∫°o MediaRecorder m·ªõi v·ªõi format ƒë∆∞·ª£c h·ªó tr·ª£
          let options = { videoBitsPerSecond: 500000 };

          if (MediaRecorder.isTypeSupported("video/mp4")) {
            options.mimeType = "video/mp4";
          } else if (MediaRecorder.isTypeSupported("video/webm;codecs=vp8")) {
            options.mimeType = "video/webm;codecs=vp8";
          } else if (MediaRecorder.isTypeSupported("video/webm")) {
            options.mimeType = "video/webm";
          }

          this.mediaRecorder = new MediaRecorder(this.mediaStream, options);

          this.mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
              this.currentVideoBlob = event.data;
              console.log("üìπ New video recorded:", event.data.size, "bytes");

              this.mediaStatus.textContent = `üìπ Video m·ªõi s·∫µn s√†ng (${Math.round(
                event.data.size / 1024
              )}KB) - H√£y h·ªèi!`;
            }
          };

          this.mediaRecorder.onstop = () => {
            this.mediaStatus.textContent = "‚èπÔ∏è ƒê√£ d·ª´ng chia s·∫ª m√†n h√¨nh";
            this.updateMediaButtons(false);
          };

          // B·∫Øt ƒë·∫ßu ghi video m·ªõi
          this.mediaRecorder.start();
          this.mediaStatus.textContent =
            "üìπ ƒêang ghi video m·ªõi - S·∫µn s√†ng cho c√¢u h·ªèi ti·∫øp theo";
        }

        stopCapture() {
          this.isRecording = false;

          // Stop MediaRecorder n·∫øu c√≥
          if (this.mediaRecorder) {
            this.mediaRecorder.stop();
            this.mediaRecorder = null;
          }

          // Stop frame capture interval
          if (this.frameInterval) {
            clearInterval(this.frameInterval);
            this.frameInterval = null;
          }

          // Clean up video elements
          if (this.videoElement) {
            this.videoElement.pause();
            this.videoElement.srcObject = null;
            this.videoElement = null;
          }

          if (this.canvas) {
            this.canvas = null;
            this.ctx = null;
          }

          // Clean up data
          this.frameSequence = [];
          this.audioChunks = [];

          // Stop media stream
          if (this.mediaStream) {
            this.mediaStream.getTracks().forEach((track) => track.stop());
            this.mediaStream = null;
          }

          this.updateMediaButtons(false);
          this.mediaStatus.textContent = "";
        }

        updateMediaButtons(isRecording) {
          this.screenBtn.disabled = isRecording || !this.isConnected;
          this.stopBtn.disabled = !isRecording;
          this.stopBtn.style.display = isRecording ? "inline-block" : "none";

          if (isRecording) {
            this.screenBtn.classList.add("active");
          } else {
            this.screenBtn.classList.remove("active");
          }
        }
      }

      document.addEventListener("DOMContentLoaded", () => {
        new TextChatClient();
      });
    </script>
  </body>
</html>
