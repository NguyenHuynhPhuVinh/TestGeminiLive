import express from "express";
import { WebSocketServer } from "ws";
import { createServer } from "http";
import path from "path";
import { fileURLToPath } from "url";
import dotenv from "dotenv";
import { GoogleGenAI, Modality } from "@google/genai";

// Load environment variables
dotenv.config();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
const server = createServer(app);
const wss = new WebSocketServer({ server });

const PORT = process.env.TEXT_PORT || 3001;

// Middleware
app.use(express.json());
app.use(express.static(__dirname));

// Ki·ªÉm tra API key
if (
  !process.env.GEMINI_API_KEY ||
  process.env.GEMINI_API_KEY === "your_api_key_here"
) {
  console.error("‚ùå Vui l√≤ng c·∫≠p nh·∫≠t GEMINI_API_KEY trong file .env");
  console.log(
    "üìù B·∫°n c√≥ th·ªÉ l·∫•y API key t·∫°i: https://aistudio.google.com/app/apikey"
  );
}

const ai = new GoogleGenAI({
  apiKey: process.env.GEMINI_API_KEY,
});

// WebSocket connection handler
wss.on("connection", (ws) => {
  console.log("üîó Client k·∫øt n·ªëi WebSocket");

  let geminiSession = null;
  let responseQueue = [];

  // Helper functions cho Gemini Live
  async function waitMessage() {
    let done = false;
    let message = undefined;
    while (!done) {
      message = responseQueue.shift();
      if (message) {
        done = true;
      } else {
        await new Promise((resolve) => setTimeout(resolve, 100));
      }
    }
    return message;
  }

  async function handleTurn() {
    const turns = [];
    let done = false;
    while (!done) {
      const message = await waitMessage();
      turns.push(message);
      if (message.serverContent && message.serverContent.turnComplete) {
        done = true;
      }
    }
    return turns;
  }

  ws.on("message", async (data) => {
    try {
      const message = JSON.parse(data);

      switch (message.type) {
        case "connect":
          await handleConnect(message);
          break;
        case "sendText":
          await handleSendText(message);
          break;
        case "sendTextWithVideo":
          await handleSendTextWithVideo(message);
          break;
        case "sendTextWithFrameSequence":
          await handleSendTextWithFrameSequence(message);
          break;
        case "disconnect":
          await handleDisconnect();
          break;
        default:
          console.log("‚ùì Unknown message type:", message.type);
      }
    } catch (error) {
      console.error("‚ùå Error processing message:", error);
      ws.send(
        JSON.stringify({
          type: "error",
          message: error.message,
        })
      );
    }
  });

  async function handleConnect(message) {
    try {
      console.log("üîó Connecting to Gemini Live (Text Only)...");

      const config = {
        responseModalities: [Modality.TEXT], // CH·ªà tr·∫£ v·ªÅ text, KH√îNG c√≥ audio
        systemInstruction:
          message.systemInstruction ||
          "B·∫°n l√† m·ªôt tr·ª£ l√Ω AI th√¥ng minh c√≥ th·ªÉ xem v√† ph√¢n t√≠ch h√¨nh ·∫£nh t·ª´ m√†n h√¨nh ng∆∞·ªùi d√πng. Khi nh·∫≠n ƒë∆∞·ª£c h√¨nh ·∫£nh, h√£y m√¥ t·∫£ chi ti·∫øt v√† ch√≠nh x√°c nh·ªØng g√¨ b·∫°n th·∫•y. Tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát th√¢n thi·ªán, c·ª• th·ªÉ v√† h·ªØu √≠ch.",
      };

      geminiSession = await ai.live.connect({
        model: "gemini-live-2.5-flash-preview",
        callbacks: {
          onopen: () => {
            console.log("‚úÖ Connected to Gemini Live");
            ws.send(
              JSON.stringify({
                type: "connected",
                message: "ƒê√£ k·∫øt n·ªëi v·ªõi Gemini Live (Text Only)",
              })
            );
          },
          onmessage: (msg) => {
            responseQueue.push(msg);

            // Debug log ƒë·ªÉ xem structure c·ªßa message
            console.log(
              "üì® Received message type:",
              typeof msg,
              Object.keys(msg)
            );

            // ∆Øu ti√™n x·ª≠ l√Ω msg.text tr∆∞·ªõc
            if (msg.text) {
              console.log("üìù Sending text chunk:", msg.text);
              ws.send(
                JSON.stringify({
                  type: "textChunk",
                  text: msg.text,
                })
              );
            }
            // Ch·ªâ x·ª≠ l√Ω modelTurn.parts n·∫øu kh√¥ng c√≥ msg.text
            else if (msg.serverContent?.modelTurn?.parts) {
              const textParts = msg.serverContent.modelTurn.parts
                .filter((part) => part.text)
                .map((part) => part.text);
              if (textParts.length > 0) {
                console.log(
                  "üìù Sending model turn parts:",
                  textParts.join(" ")
                );
                ws.send(
                  JSON.stringify({
                    type: "textChunk",
                    text: textParts.join(" "),
                  })
                );
              }
            }

            // B√°o hi·ªáu turn complete
            if (msg.serverContent?.turnComplete) {
              console.log("‚úÖ Turn complete");
              ws.send(
                JSON.stringify({
                  type: "turnComplete",
                })
              );
            }
          },
          onerror: (e) => {
            console.error("‚ùå Gemini error:", e.message);
            ws.send(
              JSON.stringify({
                type: "error",
                message: e.message,
              })
            );
          },
          onclose: (e) => {
            console.log("üîå Gemini connection closed:", e.reason);
            ws.send(
              JSON.stringify({
                type: "disconnected",
                message: "ƒê√£ ng·∫Øt k·∫øt n·ªëi v·ªõi Gemini Live",
              })
            );
          },
        },
        config: config,
      });
    } catch (error) {
      console.error("‚ùå Failed to connect to Gemini:", error);
      ws.send(
        JSON.stringify({
          type: "error",
          message: "Kh√¥ng th·ªÉ k·∫øt n·ªëi v·ªõi Gemini Live: " + error.message,
        })
      );
    }
  }

  async function handleSendText(message) {
    if (!geminiSession) {
      ws.send(
        JSON.stringify({
          type: "error",
          message: "Ch∆∞a k·∫øt n·ªëi v·ªõi Gemini Live",
        })
      );
      return;
    }

    try {
      console.log("üì§ Sending text only to Gemini:", message.text);

      // Ch·ªâ g·ª≠i text (kh√¥ng k√®m video)
      geminiSession.sendClientContent({
        turns: message.text,
        turnComplete: true,
      });

      // B√°o hi·ªáu ƒëang x·ª≠ l√Ω
      ws.send(
        JSON.stringify({
          type: "processing",
          message: "ƒêang x·ª≠ l√Ω tin nh·∫Øn...",
        })
      );
    } catch (error) {
      console.error("‚ùå Error sending text:", error);
      ws.send(
        JSON.stringify({
          type: "error",
          message: "L·ªói khi g·ª≠i tin nh·∫Øn: " + error.message,
        })
      );
    }
  }

  async function handleSendTextWithVideo(message) {
    if (!geminiSession) {
      ws.send(
        JSON.stringify({
          type: "error",
          message: "Ch∆∞a k·∫øt n·ªëi v·ªõi Gemini Live",
        })
      );
      return;
    }

    try {
      console.log("üì§ Sending text with video to Gemini:", message.text);
      console.log("üìä Video data size:", message.videoData.length);
      console.log("üìä MIME type:", message.mimeType);

      // Ki·ªÉm tra k√≠ch th∆∞·ªõc video
      const videoSizeKB = Math.round((message.videoData.length * 0.75) / 1024); // Base64 to bytes
      console.log("üìä Video size:", videoSizeKB, "KB");

      if (videoSizeKB > 15000) {
        // > 15MB
        console.log("‚ö†Ô∏è Video qu√° l·ªõn, b·ªè qua video v√† ch·ªâ g·ª≠i text");
        geminiSession.sendClientContent({
          turns: message.text,
          turnComplete: true,
        });
        return;
      }

      // G·ª≠i image frame thay v√¨ video (theo approach c·ªßa Medium article)
      console.log(
        "üñºÔ∏è Sending image frame via sendClientContent with inlineData..."
      );

      // Detect if this is an image or video based on MIME type
      let mimeType = message.mimeType || "image/jpeg";
      if (mimeType.startsWith("video/")) {
        console.log("‚ö†Ô∏è Converting video MIME type to image/jpeg");
        mimeType = "image/jpeg";
      }

      const turns = [
        message.text,
        {
          inlineData: {
            data: message.videoData,
            mimeType: mimeType,
          },
        },
      ];

      geminiSession.sendClientContent({
        turns: turns,
        turnComplete: true,
      });

      // B√°o hi·ªáu ƒëang x·ª≠ l√Ω
      ws.send(
        JSON.stringify({
          type: "processing",
          message: "ƒêang x·ª≠ l√Ω tin nh·∫Øn v·ªõi video context...",
        })
      );
    } catch (error) {
      console.error("‚ùå Error sending text with video:", error);
      ws.send(
        JSON.stringify({
          type: "error",
          message: "L·ªói khi g·ª≠i tin nh·∫Øn v·ªõi video: " + error.message,
        })
      );
    }
  }

  async function handleSendTextWithFrameSequence(message) {
    if (!geminiSession) {
      ws.send(
        JSON.stringify({
          type: "error",
          message: "Ch∆∞a k·∫øt n·ªëi v·ªõi Gemini Live",
        })
      );
      return;
    }

    try {
      console.log(
        `üì§ Sending text with ${message.totalFrames} frames to Gemini:`,
        message.text
      );
      console.log(`üìä Total size: ${Math.round(message.totalSize / 1024)}KB`);

      // Ki·ªÉm tra k√≠ch th∆∞·ªõc t·ªïng
      if (message.totalSize > 15 * 1024 * 1024) {
        // > 15MB
        console.log("‚ö†Ô∏è Frame sequence qu√° l·ªõn, ch·ªâ g·ª≠i text");
        geminiSession.sendClientContent({
          turns: message.text,
          turnComplete: true,
        });
        return;
      }

      // T·∫°o turns array v·ªõi text + t·∫•t c·∫£ frames
      const turns = [message.text];

      // Th√™m t·∫•t c·∫£ frames v√†o turns
      message.frames.forEach((frame, index) => {
        turns.push({
          inlineData: {
            data: frame.data,
            mimeType: frame.mimeType,
          },
        });
      });

      console.log(
        `üñºÔ∏è Sending ${message.totalFrames} frames via sendClientContent...`
      );

      geminiSession.sendClientContent({
        turns: turns,
        turnComplete: true,
      });

      // B√°o hi·ªáu ƒëang x·ª≠ l√Ω
      ws.send(
        JSON.stringify({
          type: "processing",
          message: `ƒêang x·ª≠ l√Ω tin nh·∫Øn v·ªõi ${message.totalFrames} frames...`,
        })
      );
    } catch (error) {
      console.error("‚ùå Error sending text with frame sequence:", error);
      ws.send(
        JSON.stringify({
          type: "error",
          message: "L·ªói khi g·ª≠i tin nh·∫Øn v·ªõi frames: " + error.message,
        })
      );
    }
  }

  async function handleDisconnect() {
    if (geminiSession) {
      geminiSession.close();
      geminiSession = null;
      responseQueue = [];
    }
  }

  ws.on("close", () => {
    console.log("üîå Client ng·∫Øt k·∫øt n·ªëi WebSocket");
    if (geminiSession) {
      geminiSession.close();
    }
  });
});

// Routes
app.get("/", (req, res) => {
  res.sendFile(path.join(__dirname, "text-chat.html"));
});

app.get("/api/status", (req, res) => {
  res.json({
    status: "running",
    mode: "text-only",
    model: "gemini-live-2.5-flash-preview",
    hasApiKey: !!(
      process.env.GEMINI_API_KEY &&
      process.env.GEMINI_API_KEY !== "your_api_key_here"
    ),
  });
});

// Start server
server.listen(PORT, () => {
  console.log(`üöÄ Text Chat Server ƒëang ch·∫°y t·∫°i http://localhost:${PORT}`);
  console.log(
    `üì± M·ªü tr√¨nh duy·ªát v√† truy c·∫≠p http://localhost:${PORT} ƒë·ªÉ chat v·ªõi Gemini`
  );

  if (
    !process.env.GEMINI_API_KEY ||
    process.env.GEMINI_API_KEY === "your_api_key_here"
  ) {
    console.log("‚ö†Ô∏è  Nh·ªõ c·∫≠p nh·∫≠t API key trong file .env tr∆∞·ªõc khi test!");
  }
});
